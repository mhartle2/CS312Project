<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Babylon - Basic scene</title>
        <style>
        html, body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        }
        #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
        }
        </style>
        <script src="babylon.js"></script>
        <!--<script src="hand.js"></script>-->
        <!--<script src="cannon.js"></script>  optional physics engine -->
    </head>
    <body>

    <!-- Need to change to % based instead of actual px. -->
    <div style="position: absolute;">
    	<IMG STYLE="position:absolute; TOP:3px; LEFT:3px; WIDTH:65px; HEIGHT:55px;" SRC="Lives.png">
    </div>

    <div style="position: absolute; LEFT: 3%; TOP: 2%;">
    	<IMG style="position:absolute; width:34px; height:24px; " src="Life.jpg" id="livesOne" >
    </div>

    <div style="position: absolute; LEFT: 5%; TOP: 2%;">
        <IMG style="position:absolute; width:34px; height:24px; " src="Life.jpg" id="livesTwo" >
    </div>

        <div style="position: absolute; LEFT: 7%; TOP: 2%;">
        <IMG style="position:absolute; width:34px; height:24px; " src="Life.jpg" id="livesThree" >
    </div>



    <div id="timer" style="position:absolute; color:white; TOP: 3%; LEFT: 95%;" font size="30"></div>


        <canvas id="renderCanvas"></canvas>
        <script type="text/javascript">
        // Get the canvas element from our HTML below
        var canvas = document.querySelector("#renderCanvas");
        // Load the BABYLON 3D engine
        var engine = new BABYLON.Engine(canvas, true);
        // -------------------------------------------------------------
        // Here begins a function that we will 'call' just after it's built

        var lifeCount;
        var dead;
        var gameOver;


        function initialize()
        {
            lifeCount = 3;
            dead = false;
            gameOver = false;
            countdown( "timer", 1, 5 );
        }

        initialize();

        var createScene = function () {
        // Now create a basic Babylon Scene object
			var scene = new BABYLON.Scene(engine);
        // Change the scene background color to green.
			scene.clearColor = new BABYLON.Color3(0.5, .2, 0.6);
        // This creates and positions a free camera
			var camera = new BABYLON.ArcRotateCamera("FollowCamera", 4.712, 1, 20, new BABYLON.Vector3(0, 15, -45), scene);

			var groundArray = new Array();
			//camera.keysUp = [];
			//camera.keysDown = [];
			//camera.keysLeft = [];
			//camera.keysRight = [];
			//var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
			// This targets the camera to scene origin
			//camera.setTarget(BABYLON.Vector3.Zero());
			// This attaches the camera to the canvas
			scene.activeCamera.attachControl(canvas);


			// This creates a light, aiming 0,1,0 - to the sky.
			var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
			// Dim the light a small amount
			light.intensity = 1;
			// Let's try our built-in 'sphere' shape. Params: name, subdivisions, size, scene


			var goal = BABYLON.Mesh.CreateBox("goal", 1, scene);
			goal.material = new BABYLON.StandardMaterial("goalTexture", scene);
			goal.material.diffuseColor = new BABYLON.Color3(1, 1, 0);
			goal.position.x = 26 + 15 * Math.cos(15 * Math.PI / 180);
			goal.position.y = 1+ 15 * Math.sin(30 * Math.PI / 180) + 15 * Math.sin(20 * Math.PI / 180);
			goal.position.z = 18.5 + 15 * Math.cos(30 * Math.PI / 180);
			goal.computeWorldMatrix(true);
		
			//CHANGING

			var sphere = BABYLON.Mesh.CreateSphere("sphere1", 16, 2, scene);
            sphere.position.x = 0
			sphere.position.y = 1;
			sphere.position.z = 5;
			sphere.visibility = true;
			sphere.computeWorldMatrix(true);

			camera.target = sphere;
			scene.activeCamera = camera;

			groundArray = createGround(scene);
			
			
			var materialSphere5 = new BABYLON.StandardMaterial("texture5", scene);
			materialSphere5.diffuseTexture = new BABYLON.Texture("textures/amiga.jpg", scene);
			materialSphere5.diffuseTexture.hasAlpha = true;

			sphere.material = materialSphere5;

			var skybox = BABYLON.Mesh.CreateBox("skyBox", 1000.0, scene);
			var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
			skyboxMaterial.backFaceCulling = false;
			skyboxMaterial.disableLighting = true;
			skybox.material = skyboxMaterial;

			skybox.infiniteDistance = true;

			skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
			skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
			skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/skyBox", scene);
			skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;

			skybox.renderingGroupId = 0;

			// Leave this function
			// -z
			var back = false;
			// +z
			var forward = false;
			// -x
			var left = false;
			// +x
			var right = false;
			var forwardSpeed = 0;
			var backSpeed = 0;
			var rightSpeed = 0;
			var leftSpeed = 0;

			window.addEventListener("keydown", function (e) {
				// w -z

                if (gameOver == false)
                {
				    if (e.keyCode == 87) {
				    	back = false;
    					forward = true;
    				}
    				// s +z
    				if (e.keyCode == 83) {
    					forward = false;
    					back = true;
    				}
    				// a -x
    				if (e.keyCode == 65) {
    					left = true;
    					right = false;
    				}
    				// d +x
    				if (e.keyCode == 68) {
    					left = false;
    					right = true;
    				}
                }
			});
			window.addEventListener("keyup", function (e) {
				// w -z
				

            
                if (e.keyCode == 87) {
					back = false;
					forward = false;
				}
				// s +z
				if (e.keyCode == 83) {
					forward = false;
					back = false;
				}
				// a -x
				if (e.keyCode == 65) {
					left = false;
					right = false;
				}
				// d +x
				if (e.keyCode == 68) {
					left = false;
					right = false;
				}
				
				if (e.keyCode == 32) {
					sphere.position.y = 1;
					sphere.position.x = 0;
					sphere.position.z = 0;
				}
             
			});

			var collisionGround;
			var collisionLowGround = false;
			scene.registerBeforeRender(function () {
				goal.rotation.y += .01;
				
				camera.target = sphere.position;

				// MOVE FORWARD
				if (forward && forwardSpeed < 0.5 && backSpeed <= 0) {
					forwardSpeed += 0.02;
					//console.log("moving foward");
					//sphere.position.z -= .007;
				} else if (forwardSpeed > 0 && back) {
					forwardSpeed -= 0.03;
					//console.log("breaking");
					//sphere.position.z += .007;
				} else if (forwardSpeed > 0 && !back) {
					// console.log("slowing");
					forwardSpeed -= 0.01;
				}

				// MOVE BACKWARD
				if (back && backSpeed < 0.5 && forwardSpeed <= 0) {
					backSpeed += 0.02;

					//sphere.position.z -= .007;
				} else if (backSpeed > 0 && forward) {
					backSpeed -= 0.03;
					//sphere.position.z += .007;
				} else if (backSpeed > 0 && !forward) {
					backSpeed -= 0.01;
				}

				// MOVE LEFT
				if (left && leftSpeed < 0.5 && rightSpeed <= 0) {
					leftSpeed += 0.02;
					//console.log("moving foward");
					//sphere.position.z -= .007;
				} else if (leftSpeed > 0 && right) {
					leftSpeed -= 0.03;
					//console.log("breaking");
					//sphere.position.z += .007;
				} else if (leftSpeed > 0 && !right) {
					// console.log("slowing");
					leftSpeed -= 0.01;
				}

				// MOVE RIGHT
				if (right && rightSpeed < 0.5 && leftSpeed <= 0) {
					rightSpeed += 0.02;
					//console.log("moving foward");
					//sphere.position.z -= .007;
				} else if (rightSpeed > 0 && left) {
					rightSpeed -= 0.03;
					//console.log("breaking");
					//sphere.position.z += .007;
				} else if (rightSpeed > 0 && !left) {
					// console.log("slowing");
					rightSpeed -= 0.01;
				}

				collisionGround = isTouchingGround(groundArray, sphere);
				if (collisionGround.length < 1) {
					collisionGround = false;
				}
				
				
				var gravityA = .2;
				var gravityV = .2;
				gravityV += gravityA;
				
				// If not colliding, apply gravity
				if (!collisionGround) {
					sphere.position.y -= gravityV;
				
				// If so, apply slope gravity
				} else {
					collisionLowGround = collisionGround[0];
					if (collisionGround.length > 1) {
						if ((collisionGround[0].position.y < collisionGround[1].position.y) && !gravityV) {
								collisionLowGround = collisionGround[0];
						} else {
							collisionLowGround = collisionGround[1];
						}
					}
					sphere.position.y -= gravityV * Math.sin(-collisionLowGround.rotation.z) * Math.sin (-collisionLowGround.rotation.z)
									   + gravityV * Math.sin(collisionLowGround.rotation.x) * Math.sin(collisionLowGround.rotation.x);
					sphere.position.x += gravityV * Math.sin(-collisionLowGround.rotation.z) * Math.cos(-collisionLowGround.rotation.z);
					sphere.position.z += gravityV * Math.sin(collisionLowGround.rotation.x) * Math.cos(collisionLowGround.rotation.x);
					
					if ((collisionLowGround.rotation.z + collisionLowGround.rotation.x) == 0) {
						//console.log( "this" + collisionLowGround.position.y)
						sphere.position.y = collisionLowGround.position.y + 1;
					}
					gravityV = 0;
					
				}
				
				

                //Death
                if (sphere.position.y <= -50)
                {
                    dead = true;
                    death();
                    
                    //Add game reset
                    sphere.position.x = 0;
                    sphere.position.y = 1;
                    sphere.position.z = 5;
                }


				
				var collisionHighGround = false;
				
				if (collisionGround.length > 1) {
					collisionHighGround = (collisionGround[0].position.y > collisionGround[1].position.y) ? collisionGround[0] : collisionGround[1];
					//console.log(collisionHighGround.position.y + " : " + 
					//			collisionGround[0].position.y + " : " + collisionGround[1].position.y);
				} else if (collisionGround.length = 1) {
					collisionHighGround = collisionGround[0];
				}
				
				//if (forward)
				if (right || rightSpeed > 0) {
					if (collisionHighGround) {
						sphere.position.y += rightSpeed * Math.sin(collisionHighGround.rotation.z);
						sphere.position.x += rightSpeed * Math.cos(collisionHighGround.rotation.z);
					} else {
						sphere.position.x += rightSpeed;
					}
					sphere.rotation.z -= rightSpeed;
				}
				if (left || leftSpeed > 0) {
					if (collisionHighGround) {
						sphere.position.y -= leftSpeed * Math.sin(collisionHighGround.rotation.z);
						sphere.position.x -= leftSpeed * Math.cos(collisionHighGround.rotation.z);
					} else {
						sphere.position.x -= leftSpeed;
					}
					sphere.rotation.z += leftSpeed;
				}
				if (forward || forwardSpeed > 0) {
					if (collisionHighGround) {
						sphere.position.y += forwardSpeed * Math.sin(-collisionHighGround.rotation.x);
						sphere.position.z += forwardSpeed * Math.cos(-collisionHighGround.rotation.x);
					} else {
						sphere.position.z += forwardSpeed;
					}
					sphere.rotation.x += forwardSpeed;
					
				}
				if (back || backSpeed > 0) {
					if (collisionHighGround) {
						sphere.position.y += backSpeed * Math.sin(collisionHighGround.rotation.x);
						sphere.position.z -= backSpeed * Math.cos(collisionHighGround.rotation.x);
					} else {
						sphere.position.z -= backSpeed;
					}
					sphere.rotation.x -= backSpeed;
				}
				
				checkFinished(sphere, goal, engine);
			})
			return scene;
            }; // End of createScene function

			var checkFinished = function(sphere, goal, engine) {
				if (sphere.intersectsMesh(goal, false)) {
					engine.stopRenderLoop();
					window.setTimeout(function() {
						window.location.href = "blarg.html";
					}, 350);
				}
			}
			
            // Function that checks if ball has collided with the ground
            var isTouchingGround = function (groundArray, sphere) {
				var flag = new Array();
				var count = 0;
				for (var i = 0; i < groundArray.length; i++) {
					if (sphere.intersectsMesh(groundArray[i], true)) {
						//console.log("intersecting " + i);
						flag[count++] = groundArray[i];
						
					}
				}
				return flag;
            }

            // Function that creates the ground
            var createGround = function (scene) {
                var groundArray = new Array();
                var ground = new BABYLON.Mesh.CreateGround("ground", 7, 15, 2, scene);
				var groundMaterialGreen = new BABYLON.StandardMaterial("groundGreen", scene);
				var groundMaterialBlue = new BABYLON.StandardMaterial("groundBlue", scene)

				groundMaterialBlue.diffuseColor = new BABYLON.Color3(0, 0, 1);
				groundMaterialGreen.diffuseColor = new BABYLON.Color3(0, 1, 0);

				ground.material = groundMaterialGreen;
				ground.material.backFaceCulling = false;
                groundArray[0] = ground;

                var ground1 = new BABYLON.Mesh.CreateGround("ground1", 7, 15, 2, scene);
				ground1.material = groundMaterialBlue;
                var ground2 = new BABYLON.Mesh.CreateGround("ground2", 7, 15, 2, scene);
				ground2.material = groundMaterialGreen;
                var ground3 = new BABYLON.Mesh.CreateGround("ground3", 7, 15, 2, scene);
				ground3.material = groundMaterialBlue;
				var ground4 = new BABYLON.Mesh.CreateGround("ground4", 7, 15, 2, scene);
				ground4.material = groundMaterialBlue;
				var ground5 = new BABYLON.Mesh.CreateGround("ground5", 15, 7, 2, scene);
				ground5.material = groundMaterialGreen;
				var ground6 = new BABYLON.Mesh.CreateGround("ground6", 15, 7, 2, scene);
				ground6.material = groundMaterialBlue;
				var ground7 = new BABYLON.Mesh.CreateGround("ground7", 15, 7, 2, scene);
				ground7.material = groundMaterialBlue; 
				var ground8 = new BABYLON.Mesh.CreateGround("ground8", 15, 7, 2, scene);
				ground8.material = groundMaterialGreen;
				var ground9 = new BABYLON.Mesh.CreateGround("ground9", 25, 7, 2, scene);
				ground9.material = groundMaterialGreen;
				
                ground1.rotation.x -= 30 * Math.PI / 180;
                ground1.position.z = 7.5 * Math.cos(30 * Math.PI / 180) + 7.5;
                ground1.position.y = 7.5 * Math.sin(30 * Math.PI / 180);
                groundArray[1] = ground1;

                ground2.position.y = ground1.position.y * 2;
                ground2.position.z = ground1.position.z * 2;
                groundArray[2] = ground2;

                ground3.rotation.y = Math.PI / 2;
                ground3.position.y = ground2.position.y;
                ground3.position.z = ground2.position.z + 4;
                ground3.position.x = 11;
                groundArray[3] = ground3;
				
				ground4.rotation.x = 15 * Math.PI / 180;
				ground4.position.z = -7.5 * Math.cos(15 * Math.PI / 180) - 7.5;
                ground4.position.y = 7.5 * Math.sin(15 * Math.PI / 180);
                groundArray[4] = ground4;
				
				ground5.rotation.z = 20 * Math.PI / 180;
				ground5.position.z = ground3.position.z;
				ground5.position.x = 18.5 + 7.5 * Math.cos(20 * Math.PI / 180);
                ground5.position.y = 7.5 + 7.5 * Math.sin(20 * Math.PI / 180);
				groundArray[5] = ground5;
				
				ground6.rotation.z = -15 * Math.PI / 180;
				ground6.position.x = -3.5 - 7.5 * Math.cos(15 * Math.PI / 180);
                ground6.position.y = 7.5 * Math.sin(15 * Math.PI / 180);
				groundArray[6] = ground6;
				
				ground7.position.y = ground3.position.y + 15 * Math.sin(20 * Math.PI / 180);
				ground7.position.z = ground3.position.z;
				ground7.position.x = 26 + 15 * Math.cos(20 * Math.PI / 180);
				groundArray[7] = ground7;
				
				ground8.position.y = ground6.position.y * 2;
				ground8.position.z = ground6.position.z * 2;
				ground8.position.x = -26.35 * Math.cos(15 * Math.PI / 180);
				groundArray[8] = ground8;
				
				ground9.rotation.x -= 30 * Math.PI / 180;
				ground9.position.x = 16;
                ground9.position.z = 7.5 * Math.cos(30 * Math.PI / 180) + 7.5;
                ground9.position.y = 7.5 * Math.sin(30 * Math.PI / 180);
				groundArray[9] = ground9;

                return groundArray;
            }

            // -------------------------------------------------------------
            // Now, call the createScene function that you just finished creating
            var scene = createScene();
            // Register a render loop to repeatedly render the scene
            engine.runRenderLoop(function () {
                scene.render();
            });
            // Watch for browser/canvas resize events
            window.addEventListener("resize", function () {
                engine.resize();
            });


function countdown( elementName, minutes, seconds )
{
    var element, endTime, hours, mins, msLeft, time;

    function twoDigits( n )
    {
        return (n <= 9 ? "0" + n : n);
    }

    function updateTimer()
    {
        msLeft = endTime - (+new Date);
        if ( msLeft < 1000 ) {
            element.innerHTML = "countdown's over!";
        } else {
            time = new Date( msLeft );
            hours = time.getUTCHours();
            mins = time.getUTCMinutes();
            element.innerHTML = (hours ? hours + ':' + twoDigits( mins ) : mins) + ':' + twoDigits( time.getUTCSeconds() );
            setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );
        }
    }

    element = document.getElementById( elementName );
    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;
    updateTimer();
}





function death()
{
    console.log(lifeCount);
    lifeCount--;

    if (lifeCount == 2 && dead == true)
    {
        var lifeImage = document.getElementById('livesThree');
        lifeImage.parentNode.removeChild(lifeImage);   
        dead = false; 
    }

    else if (lifeCount == 1 && dead == true)
    {
        var lifeImage = document.getElementById('livesTwo');
        lifeImage.parentNode.removeChild(lifeImage);    
        dead = false;
    }

    else if (lifeCount == 0 && dead == true)
    {
        var lifeImage = document.getElementById('livesOne');
        lifeImage.parentNode.removeChild(lifeImage);    
        gameOver = true;
    }

}


        </script>





    </body>
</html>

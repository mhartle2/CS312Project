<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Marble Quest</title>
        <style>
        html, body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        }
        #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
        }

        h1
        {
            
            text-shadow: 0px 2px 3px #666;
        }
   
        </style>
        <script src="babylon.js"></script>
        <!--<script src="hand.js"></script>-->
        <!--<script src="cannon.js"></script>  optional physics engine -->
    </head>
    <body>

    <!-- Need to change to % based instead of actual px. -->
    <div style="position: absolute; TOP: 1.2%; LEFT: .20%;">
        <IMG STYLE="position:absolute; WIDTH:100px; HEIGHT:80px;" SRC="Lives.png">
    </div>

    <div style="position: absolute; LEFT: 4.76%; TOP: 3%;">
        <IMG style="position:absolute; width:40px; height:30px; " src="Life.jpg" id="livesOne" >
    </div>

    <div style="position: absolute; LEFT: 6.75%; TOP: 3%;">
        <IMG style="position:absolute; width:40px; height:30px; " src="Life.jpg" id="livesTwo" >
    </div>

        <div style="position: absolute; LEFT: 8.75%; TOP: 3%;">
        <IMG style="position:absolute; width:40px; height:30px; " src="Life.jpg" id="livesThree" >
    </div>



    <div id="timer" style="position:absolute; color:white; TOP: 0.2%; LEFT: 95%;" font size="300" >
    </div>


        <canvas id="renderCanvas"></canvas>
        <script type="text/javascript">
        // Get the canvas element from our HTML below
        var canvas = document.querySelector("#renderCanvas");
        // Load the BABYLON 3D engine
        var engine = new BABYLON.Engine(canvas, true);
        // -------------------------------------------------------------
        // Here begins a function that we will 'call' just after it's built

        var lifeCount;
        var dead;
        var gameOver;
        var camera;
        var scene;

        var sphere;

        var o1Bool;
        var o2Bool;
        var o3Bool;
        var o4Bool;
        var o5Bool;

        var numBoxesLeft;

        var collisionGround;

        var powerBool;

        var powerUpOne;

        var particleOne;

        var jumping;
        var jumpDistance;
        var g16up;
        var g16down;

        var youWin;
        var onlyonerun;

        function initialize()
        {
            var groundArray = new Array();
            lifeCount = 3;
            dead = false;
            gameOver = false;
            countdown( "timer", 3, 0 );
            scene = new BABYLON.Scene(engine);
            camera = new BABYLON.ArcRotateCamera("FollowCamera", 4.712, 1, 20, new BABYLON.Vector3(0, 15, -45), scene);
            sphere = BABYLON.Mesh.CreateSphere("sphere1", 16, 2, scene);
            camera.target = sphere.position;


            // material
            var mat = new BABYLON.StandardMaterial("mat1", scene);
            mat.alpha = 1.0;
            mat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 1.0);
            mat.backFaceCulling = false;
            //mat.wireframe = true; 
            
            // simple helix, single path
            path1 = [];
            for (var i = 0; i <= 60; i++) {
                var v = 2.0 * Math.PI * i / 20;
                path1.push( new BABYLON.Vector3(1.1 * Math.cos(v), i/16, 1.1 * Math.sin(v)) );
            }

            //var lines = BABYLON.Mesh.CreateLines("helixLines", path1, scene);
            powerUpOne = BABYLON.Mesh.CreateRibbon("jump", [path1], true, false, 6, scene);
            powerUpOne.material = mat;

            //powerUpOne = BABYLON.Mesh.CreateBox("Shrink", 1, scene);
            powerUpOne.material = new BABYLON.StandardMaterial("ShrinkTexture", scene);
            powerUpOne.material.diffuseColor = new BABYLON.Color3(1,0,0);
            powerUpOne.position.x = 84;
            powerUpOne.position.y = 43;
            powerUpOne.position.z = 105;

            particleOne = new BABYLON.ParticleSystem("particles", 2000, scene);

            createParticles();

            o1Bool = true;
            o2Bool = true;
            o3Bool = true;
            o4Bool = true;
            o5Bool = true;

            numBoxesLeft = 5;


            powerBool = false;

            jumping = false;
            jumpDistance = 0;
            g16up = true;
            g16down = false;

            youWin = false;
            onlyonerun = true;

            var ground16;
            var ground39;
        }

        initialize();

        var createScene = function () {
        // Now create a basic Babylon Scene object

        // Change the scene background color to green.
            scene.clearColor = new BABYLON.Color3(0.5, .2, 0.6);
        // This creates and positions a free camera

		//var camera = new BABYLON.ArcRotateCamera("FollowCamera", 4.712, 1, 20, new BABYLON.Vector3(0, 15, -45), scene);

            
            //camera.keysUp = [];
            //camera.keysDown = [];
            //camera.keysLeft = [];
            //camera.keysRight = [];
            //var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
            // This targets the camera to scene origin
            //camera.setTarget(BABYLON.Vector3.Zero());
            // This attaches the camera to the canvas
            scene.activeCamera.attachControl(this.scene.getEngine().getRenderingCanvas());


            // This creates a light, aiming 0,1,0 - to the sky.
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            // Dim the light a small amount
            light.intensity = 1;
            // Let's try our built-in 'sphere' shape. Params: name, subdivisions, size, scene



            var object1 = BABYLON.Mesh.CreateBox("O1", 1, scene);
            object1.material = new BABYLON.StandardMaterial("OTexture", scene);
            object1.material.diffuseColor = new BABYLON.Color3(1,0,0);
            object1.position.x = 43;
            object1.position.y = 13;
            object1.position.z = -8;
 
            var object2 = BABYLON.Mesh.CreateBox("O2", 1, scene);
            object2.material = new BABYLON.StandardMaterial("OTexture", scene);
            object2.material.diffuseColor = new BABYLON.Color3(1,0,0);
            object2.position.x = 84.1;
            object2.position.y = -2;
            object2.position.z = 23;

            var object3 = BABYLON.Mesh.CreateBox("O3", 1, scene);
            object3.material = new BABYLON.StandardMaterial("OTexture", scene);
            object3.material.diffuseColor = new BABYLON.Color3(1,0,0);
            object3.position.x = 60;
            object3.position.y = 56;
            object3.position.z = 105;

            var object4 = BABYLON.Mesh.CreateBox("O4", 1, scene);
            object4.material = new BABYLON.StandardMaterial("OTexture", scene);
            object4.material.diffuseColor = new BABYLON.Color3(1,0,0);
            object4.position.x = 58.83;
            object4.position.y = 71.3;
            object4.position.z = -18.2;

            var object5 = BABYLON.Mesh.CreateBox("O5", 1, scene);
            object5.material = new BABYLON.StandardMaterial("OTexture", scene);
            object5.material.diffuseColor = new BABYLON.Color3(1,0,0);
            object5.position.x = 60.5;
            object5.position.y = 79;
            object5.position.z = -95.48;

            var goal = BABYLON.Mesh.CreateBox("goal", 1, scene);
            goal.material = new BABYLON.StandardMaterial("goalTexture", scene);
            //goal.material.diffuseColor = new BABYLON.Color3(1, 1, 0);
            goal.material.diffuseTexture = new BABYLON.Texture("finished.jpg", scene);
            goal.position.x = -2.6//26 + 15 * Math.cos(15 * Math.PI / 180);
            goal.position.y = 8.5//1 + 15 * Math.sin(30 * Math.PI / 180) + 15 * Math.sin(20 * Math.PI / 180);
            goal.position.z = 33.41//18.5 + 15 * Math.cos(30 * Math.PI / 180);
            goal.computeWorldMatrix(true);
        
            //CHANGING

            var outputplane = BABYLON.Mesh.CreatePlane("outputplane", 3, scene, false);             outputplane.billboardMode = BABYLON.AbstractMesh.BILLBOARDMODE_ALL;
            outputplane.material = new BABYLON.StandardMaterial("outputplane", scene);
            outputplane.position = new BABYLON.Vector3(goal.position.x, goal.position.y + 3, goal.position.z);
            outputplane.scaling.y = 0.4;
 
            var outputplaneTexture = new BABYLON.DynamicTexture("dynamic texture", 512, scene, true);
            outputplane.material.diffuseTexture = outputplaneTexture;
            outputplane.material.specularColor = new BABYLON.Color3(0, 0, 0);
            outputplane.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
            outputplane.material.backFaceCulling = false;
 
            outputplaneTexture.drawText("Boxes Left", null, 140, "bold 80px verdana", "white", "#0000AA");
 
            var context2D = outputplaneTexture.getContext();
            var out = function(data) {
                context2D.clearRect(0, 200, 512, 512);
                outputplaneTexture.drawText(data, null, 380, "140px verdana", "white", null);
            }
            
            sphere.position.x = 0
            sphere.position.y = 1;
            sphere.position.z = 5;
            sphere.visibility = true;
            sphere.computeWorldMatrix(true);

            camera.target = sphere;
            scene.activeCamera = camera;

            groundArray = createGround(scene);
            
            
            var materialSphere5 = new BABYLON.StandardMaterial("texture5", scene);
            materialSphere5.diffuseTexture = new BABYLON.Texture("stoneMarble.jpg", scene);
            materialSphere5.diffuseTexture.hasAlpha = true;

            sphere.material = materialSphere5;

            var skybox = BABYLON.Mesh.CreateBox("skyBox", 1000.0, scene);
            var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyboxMaterial.backFaceCulling = false;
            skyboxMaterial.disableLighting = true;
            skybox.material = skyboxMaterial;

            skybox.infiniteDistance = true;

            skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/skyBox", scene);
            skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;

            skybox.renderingGroupId = 0;

            // Leave this function
            // -z
            var back = false;
            // +z
            var forward = false;
            // -x
            var left = false;
            // +x
            var right = false;
            var forwardSpeed = 0;
            var backSpeed = 0;
            var rightSpeed = 0;
            var leftSpeed = 0;

            window.addEventListener("keydown", function (e) {
                // w -z
                if (gameOver == false)
                {
                    if (e.keyCode == 87) {
                        back = false;
                        forward = true;
                    }
                    // s +z
                    if (e.keyCode == 83) {
                        forward = false;
                        back = true;
                    }
                    // a -xwasdw
                    if (e.keyCode == 65) {
                        left = true;
                        right = false;
                    }
                    // d +x
                    if (e.keyCode == 68) {
                        left = false;
                        right = true;
                    }
                    if (e.keyCode == 32 && collisionGround) {
                        jumping = true;
                        if (jumpDistance == 0) {
                            jumpDistance = sphere.position.y;                            
                        }
                        
                    }
                }
            });
            window.addEventListener("keyup", function (e) {
                // w -z
                

            
                if (e.keyCode == 87) {
                    back = false;
                    forward = false;
                }
                // s +z
                if (e.keyCode == 83) {
                    forward = false;
                    back = false;
                }
                // a -x
                if (e.keyCode == 65) {
                    left = false;
                    right = false;
                }
                // d +x
                if (e.keyCode == 68) {
                    left = false;
                    right = false;
                }
                
                if (e.keyCode == 13) {
                    sphere.position.y = 1;
                    sphere.position.x = 0;
                    sphere.position.z = 0;
                }
                
             

            });

            
            var collisionLowGround = false;
			
            var gravityV = 0;
            scene.registerBeforeRender(function () {
                goal.rotation.y += .01;
                goal.rotation.z += .01;

                object1.rotation.y += .01;
                object1.rotation.z += .01;

                object2.rotation.y += .01;
                object2.rotation.z -= .01;

                object3.rotation.y += .01;
                object3.rotation.z -= .01;

                object4.rotation.y += .01;
                object4.rotation.z += .01;

                object5.rotation.y += .01;
                object5.rotation.z += .01;
                
                // Moves ground 16 up and down like an elevator
                if (g16up) {
                    ground16.position.y += .1;
                    ground39.position.y += .1;
                    ground39.position.x += .1;
                    if (ground16.position.y > 50) {
                        g16down = true;
                        g16up = false;
                    }
                }
                if (g16down) {
                    ground16.position.y -= .1;
                    ground39.position.y -= .1;
                    ground39.position.x -= .1;
                    if (ground16.position.y < 3) {
                        g16down = false;
                        g16up = true;
                    }
                }

                // Shows the number of boxes left at the goal box
                out(numBoxesLeft);


                // MOVE FORWARD
                if (forward && forwardSpeed < 0.5 && backSpeed <= 0) {
                    forwardSpeed += 0.02;
                    //console.log("moving foward");
                    //sphere.position.z -= .007;
                } else if (forwardSpeed > 0 && back) {
                    forwardSpeed -= 0.03;
                    //console.log("breaking");
                    //sphere.position.z += .007;
                } else if (forwardSpeed > 0 && !back && collisionGround) {
                    // console.log("slowing");
                    forwardSpeed -= 0.01;
                }

                // MOVE BACKWARD
                if (back && backSpeed < 0.5 && forwardSpeed <= 0) {
                    backSpeed += 0.02;

                    //sphere.position.z -= .007;
                } else if (backSpeed > 0 && forward) {
                    backSpeed -= 0.03;
                    //sphere.position.z += .007;
                } else if (backSpeed > 0 && !forward && collisionGround) {
                    backSpeed -= 0.01;
                }

                // MOVE LEFT
                if (left && leftSpeed < 0.5 && rightSpeed <= 0) {
                    leftSpeed += 0.02;
                    //console.log("moving foward");
                    //sphere.position.z -= .007;
                } else if (leftSpeed > 0 && right) {
                    leftSpeed -= 0.03;
                    //console.log("breaking");
                    //sphere.position.z += .007;
                } else if (leftSpeed > 0 && !right && collisionGround) {
                    // console.log("slowing");
                    leftSpeed -= 0.01;
                }

                // MOVE RIGHT
                if (right && rightSpeed < 0.5 && leftSpeed <= 0) {
                    rightSpeed += 0.02;
                    //console.log("moving foward");
                    //sphere.position.z -= .007;
                } else if (rightSpeed > 0 && left) {
                    rightSpeed -= 0.03;
                    //console.log("breaking");
                    //sphere.position.z += .007;
                } else if (rightSpeed > 0 && !left && collisionGround) {
                    // console.log("slowing");
                    rightSpeed -= 0.01;
                }
				
				//if (jumping > 0) {
				//	sphere.position.y += jumping;
				//}

                collisionGround = isTouchingGround(groundArray, sphere);
                if (collisionGround.length < 1) {
                    collisionGround = false;
                }
                
                //console.log(jumpDistance);
                var gravityA = .01;
                gravityV += gravityA;
            
                // If not colliding, apply gravity
                if (!collisionGround && !jumping && !powerBool) {
                    sphere.position.y -= gravityV;
                    //console.log("falling");
                // If so, apply slope gravity
                } 
                else if (jumping) {
                    //console.log(gravityV);
                    sphere.position.y += .3;
                    if (sphere.position.y - jumpDistance > 8) {
                        jumping = false;
                        jumpDistance = 0;
                    }
                    //console.log("jumping");
                }
                else if (powerBool) {
                    sphere.position.y += 2;
                    if (sphere.position.y - jumpDistance > 60) {
                        powerBool = false;
                        jumpDistance = 0;
                    }
                }
                else {
					gravityV = .2;
                    collisionLowGround = collisionGround[0];
                    if (collisionGround.length > 1) {
                        if ((collisionGround[0].position.y < collisionGround[1].position.y) && !gravityV) {
                                collisionLowGround = collisionGround[0];
                        } else {
                            collisionLowGround = collisionGround[1];
                        }
                    }
                    sphere.position.y -= gravityV * Math.sin(-collisionLowGround.rotation.z) * Math.sin (-collisionLowGround.rotation.z)
                                       + gravityV * Math.sin(collisionLowGround.rotation.x) * Math.sin(collisionLowGround.rotation.x);
                    sphere.position.x += gravityV * Math.sin(-collisionLowGround.rotation.z) * Math.cos(-collisionLowGround.rotation.z);
                    sphere.position.z += gravityV * Math.sin(collisionLowGround.rotation.x) * Math.cos(collisionLowGround.rotation.x);
                    
                    if ((collisionLowGround.rotation.z + collisionLowGround.rotation.x) == 0) {
                        //console.log( "this" + collisionLowGround.position.y)
                        sphere.position.y = collisionLowGround.position.y + 1;
                    }
                    gravityV = 0;
                    
                }
                


                //Death
                if (sphere.position.y <= -40)
                {
                    dead = true;
                    death();
                    
                	backSpeed = 0;
                	forwardSpeed = 0;
                	leftSpeed = 0;
                	rightSpeed = 0;


                }
                
                var collisionHighGround = false;
                
                if (collisionGround.length > 1) {
                    collisionHighGround = (collisionGround[0].position.y > collisionGround[1].position.y) ? collisionGround[0] : collisionGround[1];
                    //console.log(collisionHighGround.position.y + " : " + 
                    //          collisionGround[0].position.y + " : " + collisionGround[1].position.y);
                } 
                else if (collisionGround.length = 1) {
                    collisionHighGround = collisionGround[0];
                }
                
                //if (forward)
                if (right || rightSpeed > 0) {
                    if (collisionHighGround) {
                        sphere.position.y += rightSpeed * Math.sin(collisionHighGround.rotation.z);
                        sphere.position.x += rightSpeed * Math.cos(collisionHighGround.rotation.z);
                    } else {
                        sphere.position.x += rightSpeed;
                    }
                    sphere.rotation.z -= rightSpeed;
                }
                if (left || leftSpeed > 0) {
                    if (collisionHighGround) {
                        sphere.position.y -= leftSpeed * Math.sin(collisionHighGround.rotation.z);
                        sphere.position.x -= leftSpeed * Math.cos(collisionHighGround.rotation.z);
                    } else {
                        sphere.position.x -= leftSpeed;
                    }
                    sphere.rotation.z += leftSpeed;
                }
                if (forward || forwardSpeed > 0) {
                    if (collisionHighGround) {
                        sphere.position.y += forwardSpeed * Math.sin(-collisionHighGround.rotation.x);
                        sphere.position.z += forwardSpeed * Math.cos(-collisionHighGround.rotation.x);
                    } else {
                        sphere.position.z += forwardSpeed;
                    }
                    sphere.rotation.x += forwardSpeed;
                    
                }
                if (back || backSpeed > 0) {
                    if (collisionHighGround) {
                        sphere.position.y += backSpeed * Math.sin(collisionHighGround.rotation.x);
                        sphere.position.z -= backSpeed * Math.cos(collisionHighGround.rotation.x);
                    } else {
                        sphere.position.z -= backSpeed;
                    }
                    sphere.rotation.x -= backSpeed;
                }
                //console.log(jumping);

                var test = new BABYLON.Vector3(camera.position.x, camera.position.y, camera.position.z);
                //console.log(BABYLON.Axis.Y);
                //console.log(BABYLON.Axis.Z);

                getObject1(sphere, object1);
                getObject2(sphere, object2);
                getObject3(sphere, object3);
                getObject4(sphere, object4);
                getObject5(sphere, object5);
                powerUp();
                checkFinished(sphere, goal, outputplane);
            })
            return scene;
            }; // End of createScene function

            var checkFinished = function(sphere, goal, outputplane) {
              
                if (sphere.intersectsMesh(goal, false) && !o1Bool && !o2Bool && !o3Bool && !o4Bool && !o5Bool) {
                    winner();
                    goal.dispose();
                    goal = null;
                }
                else if (sphere.intersectsMesh(goal, false) && (o1Bool || o2Bool || o3Bool || o4Bool || o5Bool)) {
                    outputplane.material.alpha = 1;
                }
                else {
                    outputplane.material.alpha = 0;
                }
 
            }
 
            var getObject1 = function(sphere, object1) {
                if (sphere.intersectsMesh(object1, false) && o1Bool) {
                    o1Bool = false;
                    object1.dispose();
                    object1 = null;
                    numBoxesLeft -= 1;
                }
            }
 
            var getObject2 = function(sphere, object2) {
                if (sphere.intersectsMesh(object2, false) && o2Bool) {
                    o2Bool = false;
                    object2.dispose();
                    object2 = null;
                    numBoxesLeft -= 1;
                }
            }

            var getObject3 = function(sphere, object3) {
                if (sphere.intersectsMesh(object3, false) && o3Bool) {
                    o3Bool = false;
                    object3.dispose();
                    object3 = null;
                    numBoxesLeft -= 1;
                }
            }

            var getObject4 = function(sphere, object4) {
                if (sphere.intersectsMesh(object4, false) && o4Bool) {
                    o4Bool = false;
                    object4.dispose();
                    object4 = null;
                    numBoxesLeft -= 1;
                }
            }

            var getObject5 = function(sphere, object5) {
                if (sphere.intersectsMesh(object5, false) && o5Bool) {
                    o5Bool = false;
                    object5.dispose();
                    object5 = null;
                    numBoxesLeft -= 1;
                }
            }
            
            // Function that checks if ball has collided with the ground
            var isTouchingGround = function (groundArray, sphere) {

                var flag = new Array();
                var count = 0;
                for (var i = 0; i < groundArray.length; i++) {
                    if (sphere.intersectsMesh(groundArray[i], true) && !jumping) {
                        //console.log("intersecting " + i);
                        flag[count++] = groundArray[i];
                        
                    }
                }
                //jumping = false;
                return flag;
            }

            // Function that creates the ground
            var createGround = function (scene) {
                var groundArray = new Array();
                var ground = new BABYLON.Mesh.CreateGround("ground", 7, 15, 2, scene);
         //       var groundMaterialGreen = new BABYLON.StandardMaterial("groundGreen", scene);
         //       var groundMaterialBlue = new BABYLON.StandardMaterial("groundBlue", scene)


                var wood1 = new BABYLON.StandardMaterial("wood", scene);
                wood1.diffuseTexture = new BABYLON.Texture("woodOne.jpg", scene);

                var water = new BABYLON.StandardMaterial("water", scene);
                water.diffuseTexture = new BABYLON.Texture("waterTwo.jpg", scene);

                var grass1 = new BABYLON.StandardMaterial("grass", scene);
                grass1.diffuseTexture = new BABYLON.Texture("grassOne.jpg", scene);

                var grass2 = new BABYLON.StandardMaterial("grass", scene);
                grass2.diffuseTexture = new BABYLON.Texture("grassTwo.jpg", scene);

                var grass3 = new BABYLON.StandardMaterial("grass", scene);
                grass3.diffuseTexture = new BABYLON.Texture("grassThree.jpg", scene);

                var grass4 = new BABYLON.StandardMaterial("grass", scene);
                grass4.diffuseTexture = new BABYLON.Texture("grassFour.jpg", scene);

                var grass5 = new BABYLON.StandardMaterial("grass", scene);
                grass5.diffuseTexture = new BABYLON.Texture("grassFive.jpg", scene);

                var grass6 = new BABYLON.StandardMaterial("grass", scene);
                grass6.diffuseTexture = new BABYLON.Texture("grassSix.jpg", scene);

            //    groundMaterialBlue.diffuseColor = new BABYLON.Color3(0, 0, 1);
            //    groundMaterialGreen.diffuseColor = new BABYLON.Color3(0, 1, 0);

                ground.material = grass2;
                ground.material.backFaceCulling = false;
                groundArray[0] = ground;




                var ground1 = new BABYLON.Mesh.CreateGround("ground1", 7, 15, 2, scene);
                ground1.material = grass2;
                var ground2 = new BABYLON.Mesh.CreateGround("ground2", 7, 15, 2, scene);
                ground2.material = grass2;
                var ground3 = new BABYLON.Mesh.CreateGround("ground3", 7, 15, 2, scene);
                ground3.material = grass2;
                var ground4 = new BABYLON.Mesh.CreateGround("ground4", 7, 15, 2, scene);
                ground4.material = grass2;
                var ground5 = new BABYLON.Mesh.CreateGround("ground5", 15, 7, 2, scene);
                ground5.material = grass2;
                var ground6 = new BABYLON.Mesh.CreateGround("ground6", 15, 7, 2, scene);
                ground6.material = grass2;
                var ground7 = new BABYLON.Mesh.CreateGround("ground7", 15, 7, 2, scene);
                ground7.material = grass2; 
                var ground8 = new BABYLON.Mesh.CreateGround("ground8", 15, 7, 2, scene);
                ground8.material = grass2;
                var ground9 = new BABYLON.Mesh.CreateGround("ground9", 25, 7, 2, scene);
                ground9.material = grass2;
                var ground10 = new BABYLON.Mesh.CreateGround("ground10", 10, 7, 2, scene);
                ground10.material = grass2;
                var ground11 = new BABYLON.Mesh.CreateGround("ground11", 10, 7, 2, scene);
                ground11.material = grass2;
                var ground12 = new BABYLON.Mesh.CreateGround("ground12", 10, 7, 2, scene);
                ground12.material = grass2;
                var ground13 = new BABYLON.Mesh.CreateGround("ground13", 10, 7, 2, scene);
                ground13.material = grass2;
                var ground14 = new BABYLON.Mesh.CreateGround("ground14", 7, 100, 2, scene);
                ground14.material = grass2;
                var ground15 = new BABYLON.Mesh.CreateGround("ground15", 4, 15, 2, scene);
                ground15.material = grass2;
                ground16 = new BABYLON.Mesh.CreateGround("ground16", 7, 7, 2, scene);
                ground16.material = grass2;
                var ground17 = new BABYLON.Mesh.CreateGround("ground17", 15, 7, 2, scene);
                ground17.material = grass2;
                var ground18 = new BABYLON.Mesh.CreateGround("ground18", 25, 7, 2, scene);
                ground18.material = grass2;
                var ground19 = new BABYLON.Mesh.CreateGround("ground19", 8, 8, 8, scene);
                ground19.material = grass2;
                
                ground1.rotation.x -= 30 * Math.PI / 180;
                ground1.position.z = 7.5 * Math.cos(30 * Math.PI / 180) + 7.5;
                ground1.position.y = 7.5 * Math.sin(30 * Math.PI / 180);
                groundArray[1] = ground1;

                ground2.position.y = ground1.position.y * 2;
                ground2.position.z = ground1.position.z * 2;
                groundArray[2] = ground2;

                ground3.rotation.y = Math.PI / 2;
                ground3.position.y = ground2.position.y;
                ground3.position.z = ground2.position.z + 4;
                ground3.position.x = 11;
                groundArray[3] = ground3;
                
                ground4.rotation.x = 15 * Math.PI / 180;
                ground4.position.z = -7.5 * Math.cos(15 * Math.PI / 180) - 7.5;
                ground4.position.y = 7.5 * Math.sin(15 * Math.PI / 180);
                groundArray[4] = ground4;
                
                ground5.rotation.z = 20 * Math.PI / 180;
                ground5.position.z = ground3.position.z;
                ground5.position.x = 18.5 + 7.5 * Math.cos(20 * Math.PI / 180);
                ground5.position.y = 7.5 + 7.5 * Math.sin(20 * Math.PI / 180);
                groundArray[5] = ground5;
                
                ground6.rotation.z = -15 * Math.PI / 180;
                ground6.position.x = -3.5 - 7.5 * Math.cos(15 * Math.PI / 180);
                ground6.position.y = 7.5 * Math.sin(15 * Math.PI / 180);
                groundArray[6] = ground6;
                
                ground7.position.y = ground3.position.y + 15 * Math.sin(20 * Math.PI / 180);
                ground7.position.z = ground3.position.z;
                ground7.position.x = 26 + 15 * Math.cos(20 * Math.PI / 180);
                groundArray[7] = ground7;
                
                ground8.position.y = ground6.position.y * 2;
                ground8.position.z = ground6.position.z * 2;
                ground8.position.x = -26.35 * Math.cos(15 * Math.PI / 180);
                groundArray[8] = ground8;
                
                ground9.rotation.x -= 30 * Math.PI / 180;
                ground9.position.x = 16;
                ground9.position.z = 7.5 * Math.cos(30 * Math.PI / 180) + 7.5;
                ground9.position.y = 7.5 * Math.sin(30 * Math.PI / 180);
                groundArray[9] = ground9;

                ground10.rotation.x = -15 * Math.PI / 180;
                ground10.position.x = ground7.position.x + 11;
                ground10.position.y = ground7.position.y + 3.5 * Math.sin(15 * Math.PI / 180);
                ground10.position.z = ground7.position.z + 3.5 + 3.5 * Math.cos(15 * Math.PI / 180);
                groundArray[10] = ground10;

               
                ground11.rotation = ground10.rotation;
                ground11.position.x = ground10.position.x + 9;
                ground11.position.y = ground10.position.y + 7 * Math.sin(15 * Math.PI / 180);
                ground11.position.z = ground10.position.z + 7 * Math.cos(15 * Math.PI / 180);
                groundArray[11] = ground11;
               
                ground12.rotation = ground11.rotation;
                ground12.position.x = ground11.position.x + 9;
                ground12.position.y = ground11.position.y + 7 * Math.sin(15 * Math.PI / 180);
                ground12.position.z = ground11.position.z + 7 * Math.cos(15 * Math.PI / 180);
                groundArray[12] = ground12;
                
                ground13.rotation = ground12.rotation;
                ground13.position.x = ground12.position.x + 9;
                ground13.position.y = ground12.position.y + 7 * Math.sin(15 * Math.PI / 180);
                ground13.position.z = ground12.position.z + 7 * Math.cos(15 * Math.PI / 180);
                groundArray[13] = ground13;
                
                ground14.rotation.x = -30 * Math.PI / 180;
                ground14.position.x = ground13.position.x + 6;
                ground14.position.y = ground13.position.y + 7 * Math.sin(15 * Math.PI / 180);
                ground14.position.z = ground13.position.z + 7 * Math.cos(15 * Math.PI / 180);
                groundArray[14] = ground14;

                ground15.rotation = ground9.rotation;
                ground15.position.x = 26.5;
                ground15.position.y = -1.75;
                ground15.position.z = 4.5;
                groundArray[15] = ground15;

                ground16.position.x = ground8.position.x - 11;
                ground16.position.y = ground8.position.y;
                groundArray[16] = ground16;

                ground17.position.x = ground8.position.x;
                ground17.position.y = 48;
                ground17.position.z = ground8.position.z - 3;
                ground17.rotation.y = 45 * Math.PI / 180;
                groundArray[17] = ground17;

                ground18.position.x = ground17.position.x + 23;
                ground18.position.y = ground17.position.y + 10;
                ground18.position.z = ground17.position.z;
                ground18.rotation.z = 40 * Math.PI / 180;
                groundArray[18] = ground18;

                ground19.position.x = 60;
                ground19.position.y = 55;
                ground19.position.z = 105;
                groundArray[19] = ground19;

                var ground20 = new BABYLON.Mesh.CreateGround("ground20", 4, 4, 8, scene);
                ground20.material = grass2;
                ground20.position.x = ground15.position.x;
                ground20.position.z = -3.99;
                ground20.position.y = -5.5;
                groundArray[20] = ground20;

                var ground21 = new BABYLON.Mesh.CreateGround("ground21", 30, 4, 8, scene);
                ground21.material = grass2;
                ground21.position.x = 40.79;
                ground21.position.y = 3.1;
                ground21.position.z = -3.99
                ground21.rotation.z = 35 * Math.PI / 180;
                groundArray[21] = ground21;

                var ground22 = new BABYLON.Mesh.CreateGround("ground22", 4, 4, 8, scene);
                ground22.material = grass2;
                ground22.position.x = 55.07;
                ground22.position.y = 11.7;
                ground22.position.z = ground21.position.z;
                groundArray[22] = ground22;

                var ground23 = new BABYLON.Mesh.CreateGround("ground23", 15, 4, 8, scene);
                ground23.material = grass2;
                ground23.position.x = ground22.position.x - 5.5;
                ground23.position.y = ground22.position.y;
                ground23.position.z = ground22.position.z - 4;
                groundArray[23] = ground23;

                var ground24 = new BABYLON.Mesh.CreateGround("ground24", 15, 7, 8, scene);
                ground24.material = grass2;
                ground24.position.x = ground18.position.x + 17;
                ground24.position.y = ground18.position.y + 8
                ground24.position.z = ground18.position.z;
                groundArray[24] = ground24;

                var ground25 = new BABYLON.Mesh.CreateGround("ground25", 15, 7, 8, scene);
                ground25.material = grass2;
                ground25.position.x = ground24.position.x + 15;
                ground25.position.y = ground24.position.y;
                ground25.position.z = ground24.position.z - 11;
                ground25.rotation.y = 45 * Math.PI / 180;
                groundArray[25] = ground25;

                var ground26 = new BABYLON.Mesh.CreateGround("ground26", 7.5, 7, 8, scene);
                ground26.material = grass2;
                ground26.position.x = ground25.position.x + 7.95;
                ground26.position.y = ground25.position.y;
                ground26.position.z = ground25.position.z + 2.3;
                ground26.rotation.y = -45 * Math.PI / 180;
                groundArray[26] = ground26;

                var ground27 = new BABYLON.Mesh.CreateGround("ground27", 7.5, 5, 8, scene);
                ground27.material = grass2;
                ground27.position.x = ground26.position.x + 6;
                ground27.position.y = ground26.position.y;
                ground27.position.z = ground26.position.z - 4.2;
                ground27.rotation.y = 45 * Math.PI / 180;
                groundArray[27] = ground27;

                var ground28 = new BABYLON.Mesh.CreateGround("ground28", 7.5, 3, 8, scene);
                ground28.material = grass2;
                ground28.position.x = ground27.position.x + 6
                ground28.position.y = ground27.position.y;
                ground28.position.z = ground27.position.z + 2.8;
                ground28.rotation.y = -45 * Math.PI / 180;
                groundArray[28] = ground28;

                var ground29 = new BABYLON.Mesh.CreateGround("ground29", 7.5, 1.5, 8, scene);
                ground29.material = grass2;
                ground29.position.x = ground28.position.x + 5.83;
                ground29.position.y = ground28.position.y;
                ground29.position.z = ground28.position.z - 1.6;
                ground29.rotation.y = 45 * Math.PI / 180;
                groundArray[29] = ground29;

                var ground30 = new BABYLON.Mesh.CreateGround("ground30", 3, 3, 8, scene);
                ground30.material = grass2;
                ground30.position.x = ground29.position.x + 3.5;
                ground30.position.y = ground29.position.y + 4;
                ground30.position.z = ground29.position.z - 3.5;
                ground30.rotation.y = 45 * Math.PI / 180;
                groundArray[30] = ground30;

                var ground31 = new BABYLON.Mesh.CreateGround("ground31", 7, 70, 8, scene);
                ground31.material = grass2;
                ground31.position.y = 3.88;
                ground31.position.z = -56.98;
                groundArray[31] = ground31;

                var ground32 = new BABYLON.Mesh.CreateGround("ground32", 7, 7, 8, scene);
                ground32.material  = grass2;
                ground32.position.x = -7;
                ground32.position.y = ground31.position.y;
                ground32.position.z = ground31.position.z - 31.5;
                groundArray[32] = ground32;

                var ground33 = new BABYLON.Mesh.CreateGround("ground33", 7, 7, 8, scene);
                ground33.material = grass2;
                ground33.position.x = ground32.position.x;
                ground33.position.y = ground32.position.y + 4;
                ground33.position.z = ground32.position.z - 7;
                groundArray[33] = ground33;

                var ground34 = new BABYLON.Mesh.CreateGround("ground34", 7, 7, 8, scene);
                ground34.material = grass2;
                ground34.position.x = ground33.position.x + 7;
                ground34.position.y = ground33.position.y + 4;
                ground34.position.z = ground33.position.z;
                groundArray[34] = ground34;

                var ground35 = new BABYLON.Mesh.CreateGround("ground35", 7, 7, 8, scene);
                ground35.material = grass2;
                ground35.position.x = ground34.position.x;
                ground35.position.y = ground34.position.y + 4;
                ground35.position.z = ground34.position.z + 7;
                groundArray[35] = ground35;

                var ground36 = new BABYLON.Mesh.CreateGround("ground36", 7, 7, 8, scene);
                ground36.material = grass2;
                ground36.position.x = ground35.position.x - 7;
                ground36.position.y = ground35.position.y + 4;
                ground36.position.z = ground35.position.z;
                groundArray[36] = ground36;

                var ground37 = new BABYLON.Mesh.CreateGround("ground37", 7, 7, 8, scene);
                ground37.material = grass2;
                ground37.position.x = ground33.position.x;
                ground37.position.y = ground36.position.y + 4;
                ground37.position.z = ground33.position.z;
                groundArray[37] = ground37;

                var ground38 = new BABYLON.Mesh.CreateGround("ground38", 7, 7, 8, scene);
                ground38.material = grass2;
                ground38.position.x = ground34.position.x;
                ground38.position.y = ground37.position.y + 4;
                ground38.position.z = ground34.position.z;
                groundArray[38] = ground38;

                ground39 = new BABYLON.Mesh.CreateGround("ground39", 7, 7, 8, scene);
                ground39.material = grass2;
                ground39.position.x = ground34.position.x + 7;
                ground39.position.y = ground38.position.y;
                ground39.position.z = ground34.position.z;
                groundArray[39] = ground39;

                ground40 = new BABYLON.Mesh.CreateGround("ground40", 7, 7, 8, scene);
                ground40.material = grass2;
                ground40.position.x = ground39.position.x + 53.5;
                ground40.position.y = ground39.position.y + 50;
                ground40.position.z = ground39.position.z;
                groundArray[40] = ground40;

                console.log(ground40.position.x);
                console.log(ground40.position.y);
                console.log(ground40.position.z);

                return groundArray;
            }

            // -------------------------------------------------------------
            // Now, call the createScene function that you just finished creating
            var scene = createScene();
            // Register a render loop to repeatedly render the scene
            engine.runRenderLoop(function () {
                scene.render();
            });
            // Watch for browser/canvas resize events
            window.addEventListener("resize", function () {
                engine.resize();
            });


function countdown( elementName, minutes, seconds )
{
    var element, endTime, hours, mins, msLeft, time;

    function twoDigits( n )
    {
        return (n <= 9 ? "0" + n : n);
    }

    function updateTimer()
    {
        msLeft = endTime - (+new Date);
        if ( msLeft < 1000 ) {
            element.innerHTML = "<h1>0:00</h1>";
            endGame();
        } else {
            time = new Date( msLeft );
            hours = time.getUTCHours();
            mins = time.getUTCMinutes();
            element.innerHTML = '<h1>' + (hours ? hours + ':' + twoDigits( mins ) : mins) + ':' + twoDigits( time.getUTCSeconds() );
            setTimeout( updateTimer, time.getUTCMilliseconds() + 500 ) + '</h1>';
        }
    }

    element = document.getElementById( elementName );
    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;
    updateTimer();
}





function death()
{
    lifeCount--;
    if (lifeCount == 2 && dead == true)
    {
        var lifeImage = document.getElementById('livesThree');
        lifeImage.parentNode.removeChild(lifeImage);   
        dead = false; 
        sphere.position.x = 0;
        sphere.position.y = 1;
        sphere.position.z = 5;
    }

    else if (lifeCount == 1 && dead == true)
    {
        var lifeImage = document.getElementById('livesTwo');
        lifeImage.parentNode.removeChild(lifeImage);    
        dead = false;
        sphere.position.x = 0;
        sphere.position.y = 1;
        sphere.position.z = 5;
    }

    else if (lifeCount == 0 && dead == true)
    {
        var lifeImage = document.getElementById('livesOne');
        lifeImage.parentNode.removeChild(lifeImage);    
        endGame();
    }
	
}

function endGame()
{
    gameOver = true;

    if (!youWin) {
        var wah = new BABYLON.Sound("WahWahWah", "wah.mp3", scene, function () {
            wah.play(2);


            var board = BABYLON.Mesh.CreatePlane("Board",10,scene);
            board.billboardMode = BABYLON.AbstractMesh.BILLBOARDMODE_ALL;
            board.material = new BABYLON.StandardMaterial("Board",scene);
            board.position = new BABYLON.Vector3(0, 10, 5);
            board.scaling.y = 0.4;

            board.material.backFaceCulling = false;

            board.material.diffuseTexture = new BABYLON.Texture("gameOverTwo.jpg", scene);

           // var boardTexture = new BABYLON.DynamicTexture("Boardtexture", 128, scene, true);
          //  board.material.diffuseTexture = boardTexture;
            //board.material.specularColor = new BABYLON.Color3(0, 0, 0);
            board.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
            board.material.backFaceCulling = true;

           // boardTexture.drawText("Game Over", null, 60, "bold 60px verdana", "white", "#000000", "opacity = 1");


            camera.target = board;


        });
    }
}

function winner() {
    gameOver = true;
    youWin = true;
    if (onlyonerun) {
        onlyonerun = false;

        var board = BABYLON.Mesh.CreatePlane("Board",10,scene);
        board.billboardMode = BABYLON.AbstractMesh.BILLBOARDMODE_ALL;
        board.material = new BABYLON.StandardMaterial("Board",scene);
        board.position = new BABYLON.Vector3(0, 10, 5);
        board.scaling.y = 0.4;

        board.material.backFaceCulling = false;

        board.material.diffuseTexture = new BABYLON.Texture("winner.jpg", scene);

       // var boardTexture = new BABYLON.DynamicTexture("Boardtexture", 128, scene, true);
      //  board.material.diffuseTexture = boardTexture;
        //board.material.specularColor = new BABYLON.Color3(0, 0, 0);
        board.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
        board.material.backFaceCulling = true;

        camera.target = board;
    }

}

    var createTorch = function (name, x, y, z, scene, shadowGenerator, brickMaterial, woodMaterial, grassMaterial) {
        //createBrickBlock
        var brickblock = BABYLON.Mesh.CreateBox(name + "brickblock", 1, scene);
        brickblock.position = new BABYLON.Vector3(x, y, z);
        brickblock.material = brickMaterial;

        //createWood
        var torchwood = BABYLON.Mesh.CreateCylinder(name + "torchwood", 2, 0.25, 0.1, 12, 1, scene);
        torchwood.position = new BABYLON.Vector3(x, y + 1, z);
        torchwood.material = woodMaterial;

        //leafs
        var leafs2 = BABYLON.Mesh.CreateSphere(name + "leafs2", 10, 1.2, scene);
        leafs2.position = new BABYLON.Vector3(x, y + 2, z);
        leafs2.material = grassMaterial;

        shadowGenerator.getShadowMap().renderList.push(torchwood);
        shadowGenerator.getShadowMap().renderList.push(leafs2);
        shadowGenerator.getShadowMap().renderList.push(brickblock);
    }

        function createParticles()
        {
                    //Texture of each particle
            particleOne.particleTexture = new BABYLON.Texture("flare.png", scene);

            // Where the particles come from
            particleOne.emitter = powerUpOne; // the starting object, the emitter
            particleOne.minEmitBox = new BABYLON.Vector3(-1, 0, 0); // Starting all from
            particleOne.maxEmitBox = new BABYLON.Vector3(2, 2, 2); // To...



            particleOne.start();
                // Colors of all particles
            particleOne.color1 = new BABYLON.Color4(0.6, 0.9, 1.9, 0.8);
            particleOne.color2 = new BABYLON.Color4(0.2, 0.5, 1.0, 1.0);
            particleOne.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);

            // Size of each particle (random between...
            particleOne.minSize = 0.1;
            particleOne.maxSize = 0.9;

            // Life time of each particle (random between...
            particleOne.minLifeTime = 0.3;
            particleOne.maxLifeTime = 0.8;

            // Emission rate
            particleOne.emitRate = 1900;
        }


        function powerUp(){
            if (sphere.intersectsMesh(powerUpOne, false) && collisionGround) {
                  //  powerBool = false;
                  //  powerUpOne.dispose();
                powerBool = true;
                if (jumpDistance == 0) {
                    jumpDistance = sphere.position.y;                            
                }
            }
        }


        </script>





    </body>
</html>
